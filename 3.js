console.log("Завдання: 3 ==============================");

function task3() {
  function promise1() {
    return new Promise((resolve, reject) => {
      // Використовуємо setTimeout для імітації асинхронної операції, яка завершується через 1 секунду.
      setTimeout(() => {
        resolve("Проміс 1 виконано");
      }, 1000);
    });
  }

  function promise2() {
    return new Promise((resolve, reject) => {
      // Використовуємо setTimeout для імітації асинхронної операції, яка не вдається і відхиляє проміс через 2 секунди.
      setTimeout(() => {
        reject("Проміс 2 відхилено");
      }, 2000);
    });
  }

  // Використовуємо Promise.allSettled, який приймає масив промісів.
  Promise.allSettled([promise1(), promise2()])
    .then((results) => {
      // Функція then викликається, коли всі проміси вирішено або відхилено.
      // Вона приймає масив об'єктів, кожний з яких відображає стан кожного проміса.
      // Для кожного результату виводимо статус проміса.
      results.forEach((result) => {
        if (result.status === "fulfilled") {
          console.log(`Статус: ${result.status}, Результат: ${result.value}`);
        } else {
          console.log(`Статус: ${result.status}, Причина: ${result.reason}`);
        }
      });
    })
    .catch((error) => {
      console.error(error);
    })
    .finally(() => {
      // Функція finally викликається після того, як проміс вирішено або відхилено.
      // Вона використовується для виконання дій, які повинні виконуватися незалежно від того, чи було проміс вирішено чи відхилено.
      // В даному випадку просто виводимо повідомлення "Завдання 3 завершено".
      console.log("Завдання 3 завершено");
    });
}

// Викликаємо функцію task3
task3();
